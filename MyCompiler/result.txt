CONSTSYM const 1
FLOATSYM float 1
IDENT pi 1
BECOME = 1
FLOAT 3.14 1
SEMICOLON ; 1
CONSTSYM const 2
INTSYM int 2
IDENT a 2
BECOME = 2
INTEGER 5 2
COMMA , 2
IDENT b 2
BECOME = 2
INTEGER 6 2
SEMICOLON ; 2
INTSYM int 3
IDENT c 3
LBRACK [ 3
INTEGER 2 3
LBRACK ] 3
COMMA , 3
IDENT res 3
COMMA , 3
IDENT d 3
LBRACK [ 3
INTEGER 3 3
LBRACK ] 3
SEMICOLON ; 3
FLOATSYM float 4
IDENT f1 4
COMMA , 4
IDENT _root 4
SEMICOLON ; 4
CHARSYM char 5
IDENT ch 5
SEMICOLON ; 5
INTSYM int 6
IDENT add_two_nums 6
LPARENT ( 6
INTSYM int 6
IDENT a1 6
COMMA , 6
INTSYM int 6
IDENT a2 6
RPARENT ) 6
LBRACE { 6
RETURNSYM return 7
LPARENT ( 7
IDENT a1 7
PLUSSYM + 7
IDENT a2 7
RPARENT ) 7
SEMICOLON ; 7
RBRACE } 8
FLOATSYM float 9
IDENT float_div 9
LPARENT ( 9
FLOATSYM float 9
IDENT f1 9
COMMA , 9
FLOATSYM float 9
IDENT f2 9
RPARENT ) 9
LBRACE { 9
IFSYM if 10
LPARENT ( 10
IDENT f2 10
EQUAL == 10
INTEGER 0 10
RPARENT ) 10
LBRACE { 10
PRINTFSYM printf 11
LPARENT ( 11
STRING "the f2 cannot be 0" 11
RPARENT ) 11
SEMICOLON ; 11
RETURNSYM return 12
LPARENT ( 12
INTEGER 0 12
RPARENT ) 12
SEMICOLON ; 12
RBRACE } 13
ELSESYM else 14
RETURNSYM return 15
LPARENT ( 15
IDENT f1 15
DIVSYM / 15
IDENT f2 15
RPARENT ) 15
SEMICOLON ; 15
RBRACE } 16
VOIDSYM void 17
IDENT print_hello 17
LPARENT ( 17
RPARENT ) 17
LBRACE { 17
IDENT ch 18
BECOME = 18
CHARACTER 'd' 18
SEMICOLON ; 18
PRINTFSYM printf 19
LPARENT ( 19
STRING "hello" 19
RPARENT ) 19
SEMICOLON ; 19
PRINTFSYM printf 20
LPARENT ( 20
STRING "worl" 20
COMMA , 20
IDENT ch 20
RPARENT ) 20
SEMICOLON ; 20
RBRACE } 21
CHARSYM char 22
IDENT get_lower 22
LPARENT ( 22
CHARSYM char 22
IDENT c 22
RPARENT ) 22
LBRACE { 22
IFSYM if 23
LPARENT ( 23
IDENT c 23
GREATER > 23
CHARACTER 'Z' 23
RPARENT ) 23
RETURNSYM return 24
LPARENT ( 24
CHARACTER '_' 24
RPARENT ) 24
SEMICOLON ; 24
ELSESYM else 25
LBRACE { 25
IFSYM if 26
LPARENT ( 26
IDENT c 26
LESS < 26
CHARACTER 'A' 26
RPARENT ) 26
RETURNSYM return 27
LPARENT ( 27
CHARACTER '_' 27
RPARENT ) 27
SEMICOLON ; 27
ELSESYM else 28
RETURNSYM return 29
LPARENT ( 29
IDENT c 29
RPARENT ) 29
SEMICOLON ; 29
RBRACE } 30
RBRACE } 31
INTSYM int 32
IDENT cal_fibonacci_val 32
LPARENT ( 32
INTSYM int 32
IDENT n 32
RPARENT ) 32
LBRACE { 32
IFSYM if 33
LPARENT ( 33
IDENT n 33
LESSEQUAL <= 33
INTEGER 2 33
RPARENT ) 33
RETURNSYM return 34
LPARENT ( 34
INTEGER 1 34
RPARENT ) 34
SEMICOLON ; 34
ELSESYM else 35
RETURNSYM return 36
LPARENT ( 36
IDENT cal_fibonacci_val 36
LPARENT ( 36
IDENT n 36
SUBSYM - 36
INTEGER 1 36
RPARENT ) 36
PLUSSYM + 36
IDENT cal_fibonacci_val 36
LPARENT ( 36
IDENT n 36
SUBSYM - 36
INTEGER 2 36
RPARENT ) 36
RPARENT ) 36
SEMICOLON ; 36
RBRACE } 37
VOIDSYM void 38
MAINSYM main 38
LPARENT ( 38
RPARENT ) 38
LBRACE { 38
CONSTSYM const 39
FLOATSYM float 39
IDENT e 39
BECOME = 39
FLOAT 2.71 39
SEMICOLON ; 39
CHARSYM char 40
IDENT ch1 40
COMMA , 40
IDENT ch2 40
SEMICOLON ; 40
FLOATSYM float 41
IDENT sml_num 41
SEMICOLON ; 41
INTSYM int 42
IDENT x 42
COMMA , 42
IDENT y 42
SEMICOLON ; 42
INTSYM int 43
IDENT i 43
SEMICOLON ; 43
SCANFSYM scanf 44
LPARENT ( 44
IDENT x 44
COMMA , 44
IDENT y 44
RPARENT ) 44
SEMICOLON ; 44
SCANFSYM scanf 45
LPARENT ( 45
IDENT ch1 45
RPARENT ) 45
SEMICOLON ; 45
IFSYM if 46
LPARENT ( 46
IDENT x 46
GREATEREQUAL >= 46
IDENT y 46
RPARENT ) 46
LBRACE { 46
IDENT c 47
LBRACK [ 47
INTEGER 0 47
LBRACK ] 47
BECOME = 47
IDENT x 47
SEMICOLON ; 47
IDENT c 48
LBRACK [ 48
INTEGER 1 48
LBRACK ] 48
BECOME = 48
IDENT y 48
SEMICOLON ; 48
RBRACE } 49
ELSESYM else 50
LBRACE { 50
IDENT c 51
LBRACK [ 51
INTEGER 0 51
LBRACK ] 51
BECOME = 51
IDENT y 51
SEMICOLON ; 51
IDENT c 52
LBRACK [ 52
INTEGER 1 52
LBRACK ] 52
BECOME = 52
IDENT x 52
SEMICOLON ; 52
RBRACE } 53
IDENT i 54
BECOME = 54
IDENT c 54
LBRACK [ 54
INTEGER 0 54
LBRACK ] 54
SUBSYM - 54
IDENT c 54
LBRACK [ 54
INTEGER 1 54
LBRACK ] 54
SEMICOLON ; 54
SEMICOLON ; 55
IDENT _root 56
BECOME = 56
FLOAT 1.23 56
SEMICOLON ; 56
IDENT f1 57
BECOME = 57
PLUSSYM + 57
FLOAT 2.33 57
SEMICOLON ; 57
IDENT res 58
BECOME = 58
INTEGER 2 58
PLUSSYM + 58
INTEGER 5 58
MULSYM * 58
IDENT add_two_nums 58
LPARENT ( 58
IDENT x 58
COMMA , 58
IDENT y 58
RPARENT ) 58
SEMICOLON ; 58
IFSYM if 59
LPARENT ( 59
IDENT res 59
RPARENT ) 59
LBRACE { 59
PRINTFSYM printf 60
LPARENT ( 60
STRING "res is not zero" 60
RPARENT ) 60
SEMICOLON ; 60
PRINTFSYM printf 61
LPARENT ( 61
IDENT res 61
MULSYM * 61
INTEGER 2 61
RPARENT ) 61
SEMICOLON ; 61
RBRACE } 62
IDENT i 63
BECOME = 63
INTEGER 0 63
SEMICOLON ; 63
WHILESYM while 64
LPARENT ( 64
IDENT i 64
NEQUAL != 64
IDENT res 64
RPARENT ) 64
LBRACE { 64
IDENT print_hello 65
LPARENT ( 65
RPARENT ) 65
SEMICOLON ; 65
IDENT i 66
BECOME = 66
IDENT i 66
PLUSSYM + 66
INTEGER 1 66
SEMICOLON ; 66
RBRACE } 67
IDENT i 68
BECOME = 68
INTEGER 2 68
SEMICOLON ; 68
IDENT ch1 69
BECOME = 69
CHARACTER 'b' 69
SEMICOLON ; 69
PRINTFSYM printf 70
LPARENT ( 70
IDENT ch1 70
PLUSSYM + 70
INTEGER 1 70
RPARENT ) 70
SEMICOLON ; 70
IDENT x 71
BECOME = 71
PLUSSYM + 71
INTEGER 6 71
SEMICOLON ; 71
IDENT res 72
BECOME = 72
IDENT cal_fibonacci_val 72
LPARENT ( 72
IDENT x 72
RPARENT ) 72
SEMICOLON ; 72
PRINTFSYM printf 73
LPARENT ( 73
STRING "the fibonacci value is" 73
COMMA , 73
IDENT res 73
RPARENT ) 73
SEMICOLON ; 73
RBRACE } 74
