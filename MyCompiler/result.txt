CONSTSYM const 1
CHARSYM char 1
IDENT tc 1
BECOME = 1
CHARACTER 'a' 1
COMMA , 1
IDENT tc2 1
BECOME = 1
CHARACTER 'A' 1
COMMA , 1
IDENT tc3 1
BECOME = 1
CHARACTER '_' 1
SEMICOLON ; 1
CONSTSYM const 2
FLOATSYM float 2
IDENT pi 2
BECOME = 2
FLOAT 3.14 2
SEMICOLON ; 2
CONSTSYM const 3
INTSYM int 3
IDENT a 3
BECOME = 3
INTEGER 5 3
COMMA , 3
IDENT b 3
BECOME = 3
INTEGER 6 3
SEMICOLON ; 3
INTSYM int 4
IDENT c 4
LBRACK [ 4
INTEGER 2 4
LBRACK ] 4
COMMA , 4
IDENT res 4
COMMA , 4
IDENT d 4
LBRACK [ 4
INTEGER 30 4
LBRACK ] 4
SEMICOLON ; 4
FLOATSYM float 5
IDENT f1 5
COMMA , 5
IDENT _root 5
SEMICOLON ; 5
CHARSYM char 6
IDENT chAABBCC 6
SEMICOLON ; 6
FLOATSYM float 7
IDENT float_div 7
LPARENT ( 7
FLOATSYM float 7
IDENT f1 7
COMMA , 7
FLOATSYM float 7
IDENT f2 7
RPARENT ) 7
LBRACE { 7
IFSYM if 8
LPARENT ( 8
IDENT f2 8
EQUAL == 8
INTEGER 0 8
RPARENT ) 8
LBRACE { 8
PRINTFSYM printf 9
LPARENT ( 9
STRING "the f2 cannot be 0" 9
RPARENT ) 9
SEMICOLON ; 9
RETURNSYM return 10
LPARENT ( 10
INTEGER 0 10
RPARENT ) 10
SEMICOLON ; 10
RBRACE } 11
ELSESYM else 12
RETURNSYM return 13
LPARENT ( 13
IDENT f1 13
DIVSYM / 13
IDENT f2 13
RPARENT ) 13
SEMICOLON ; 13
RBRACE } 14
CHARSYM char 15
IDENT get_lower 15
LPARENT ( 15
CHARSYM char 15
IDENT c 15
RPARENT ) 15
LBRACE { 15
IFSYM if 16
LPARENT ( 16
IDENT c 16
GREATER > 16
CHARACTER 'Z' 16
RPARENT ) 16
RETURNSYM return 17
LPARENT ( 17
CHARACTER '_' 17
RPARENT ) 17
SEMICOLON ; 17
ELSESYM else 18
LBRACE { 18
IFSYM if 19
LPARENT ( 19
IDENT c 19
LESS < 19
CHARACTER 'A' 19
RPARENT ) 19
RETURNSYM return 20
LPARENT ( 20
CHARACTER '_' 20
RPARENT ) 20
SEMICOLON ; 20
ELSESYM else 21
RETURNSYM return 22
LPARENT ( 22
IDENT c 22
RPARENT ) 22
SEMICOLON ; 22
RBRACE } 23
RBRACE } 24
VOIDSYM void 25
IDENT print_hello 25
LPARENT ( 25
INTSYM int 25
IDENT ph 25
COMMA , 25
CHARSYM char 25
IDENT phc 25
RPARENT ) 25
LBRACE { 25
CONSTSYM const 26
FLOATSYM float 26
IDENT f1 26
BECOME = 26
FLOAT 2.33 26
COMMA , 26
IDENT print_hello 26
BECOME = 26
FLOAT 6677.66441 26
SEMICOLON ; 26
CONSTSYM const 27
CHARSYM char 27
IDENT res 27
BECOME = 27
CHARACTER 'f' 27
SEMICOLON ; 27
INTSYM int 28
IDENT x 28
SEMICOLON ; 28
FLOATSYM float 29
IDENT lwt 29
LBRACK [ 29
INTEGER 25 29
LBRACK ] 29
COMMA , 29
IDENT lwt1 29
SEMICOLON ; 29
IDENT _root 30
BECOME = 30
FLOAT 1.26 30
SEMICOLON ; 30
IDENT x 31
BECOME = 31
IDENT pi 31
PLUSSYM + 31
IDENT d 31
LBRACK [ 31
INTEGER 2 31
LBRACK ] 31
MULSYM * 31
IDENT d 31
LBRACK [ 31
IDENT a 31
PLUSSYM + 31
IDENT b 31
LBRACK ] 31
SUBSYM - 31
IDENT d 31
LBRACK [ 31
IDENT a 31
PLUSSYM + 31
IDENT b 31
MULSYM * 31
INTEGER 2 31
PLUSSYM + 31
IDENT c 31
LBRACK [ 31
INTEGER 0 31
LBRACK ] 31
LBRACK ] 31
SEMICOLON ; 31
IDENT lwt 32
LBRACK [ 32
INTEGER 1 32
LBRACK ] 32
BECOME = 32
LPARENT ( 32
INTEGER 1 32
PLUSSYM + 32
IDENT _root 32
RPARENT ) 32
MULSYM * 32
INTEGER 2 32
PLUSSYM + 32
INTEGER 1 32
SEMICOLON ; 32
PRINTFSYM printf 33
LPARENT ( 33
STRING "lihaile" 33
RPARENT ) 33
SEMICOLON ; 33
PRINTFSYM printf 34
LPARENT ( 34
STRING "wodege" 34
COMMA , 34
IDENT ph 34
RPARENT ) 34
SEMICOLON ; 34
RBRACE } 35
VOIDSYM void 36
MAINSYM main 36
LPARENT ( 36
RPARENT ) 36
LBRACE { 36
CONSTSYM const 37
FLOATSYM float 37
IDENT e 37
BECOME = 37
FLOAT 2.71 37
SEMICOLON ; 37
CHARSYM char 38
IDENT ch1 38
COMMA , 38
IDENT ch2 38
SEMICOLON ; 38
FLOATSYM float 39
IDENT sml_num 39
SEMICOLON ; 39
INTSYM int 40
IDENT x 40
COMMA , 40
IDENT y 40
SEMICOLON ; 40
INTSYM int 41
IDENT i 41
SEMICOLON ; 41
CHARSYM char 42
IDENT kp 42
LBRACK [ 42
INTEGER 23 42
LBRACK ] 42
SEMICOLON ; 42
SCANFSYM scanf 43
LPARENT ( 43
IDENT y 43
RPARENT ) 43
SEMICOLON ; 43
SCANFSYM scanf 44
LPARENT ( 44
IDENT ch1 44
COMMA , 44
IDENT ch2 44
RPARENT ) 44
SEMICOLON ; 44
SCANFSYM scanf 45
LPARENT ( 45
IDENT sml_num 45
COMMA , 45
IDENT res 45
RPARENT ) 45
SEMICOLON ; 45
IDENT _root 46
BECOME = 46
IDENT float_div 46
LPARENT ( 46
IDENT f1 46
COMMA , 46
IDENT sml_num 46
RPARENT ) 46
SEMICOLON ; 46
SWITCHSYM switch 47
LPARENT ( 47
IDENT i 47
PLUSSYM + 47
INTEGER 1 47
RPARENT ) 47
LBRACE { 47
CASESYM case 48
INTEGER 2 48
COLON : 48
PRINTFSYM printf 49
LPARENT ( 49
STRING "the value of is 2" 49
RPARENT ) 49
SEMICOLON ; 49
CASESYM case 50
INTEGER 3 50
COLON : 50
PRINTFSYM printf 51
LPARENT ( 51
STRING "the value of i is 3" 51
RPARENT ) 51
SEMICOLON ; 51
RBRACE } 52
WHILESYM while 53
LPARENT ( 53
IDENT i 53
NEQUAL != 53
IDENT res 53
RPARENT ) 53
LBRACE { 53
IDENT i 54
BECOME = 54
IDENT i 54
PLUSSYM + 54
INTEGER 1 54
SEMICOLON ; 54
IDENT x 55
BECOME = 55
IDENT i 55
PLUSSYM + 55
INTEGER 1 55
SEMICOLON ; 55
IDENT y 56
BECOME = 56
IDENT x 56
MULSYM * 56
IDENT i 56
PLUSSYM + 56
IDENT x 56
SEMICOLON ; 56
RBRACE } 57
IDENT i 58
BECOME = 58
INTEGER 5 58
SEMICOLON ; 58
IDENT c 59
LBRACK [ 59
INTEGER 1 59
LBRACK ] 59
BECOME = 59
INTEGER 6 59
SEMICOLON ; 59
IDENT kp 60
LBRACK [ 60
IDENT x 60
MULSYM * 60
IDENT y 60
PLUSSYM + 60
INTEGER 2 60
LBRACK ] 60
BECOME = 60
IDENT a 60
SEMICOLON ; 60
IDENT f1 61
BECOME = 61
IDENT e 61
SEMICOLON ; 61
RBRACE } 62
