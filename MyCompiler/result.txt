CONSTSYM const 1
FLOATSYM float 1
IDENT pi 1
BECOME = 1
FLOAT 3.14 1
SEMICOLON ; 1
CONSTSYM const 2
INTSYM int 2
IDENT a 2
BECOME = 2
INTEGER 5 2
COMMA , 2
IDENT b 2
BECOME = 2
INTEGER 6 2
SEMICOLON ; 2
INTSYM int 3
IDENT c 3
LBRACK [ 3
INTEGER 2 3
LBRACK ] 3
COMMA , 3
IDENT res 3
COMMA , 3
IDENT d 3
LBRACK [ 3
INTEGER 3 3
LBRACK ] 3
SEMICOLON ; 3
FLOATSYM float 4
IDENT f1 4
COMMA , 4
IDENT _root 4
SEMICOLON ; 4
CHARSYM char 5
IDENT ch 5
SEMICOLON ; 5
INTSYM int 7
IDENT add_two_nums 7
LPARENT ( 7
INTSYM int 7
IDENT a1 7
COMMA , 7
INTSYM int 7
IDENT a2 7
RPARENT ) 7
LBRACE { 7
RETURNSYM return 8
LPARENT ( 8
IDENT a1 8
PLUSSYM + 8
IDENT a2 8
RPARENT ) 8
SEMICOLON ; 8
RBRACE } 9
FLOATSYM float 11
IDENT float_div 11
LPARENT ( 11
FLOATSYM float 11
IDENT f1 11
COMMA , 11
FLOATSYM float 11
IDENT f2 11
RPARENT ) 11
LBRACE { 11
IFSYM if 12
LPARENT ( 12
IDENT f2 12
EQUAL == 12
INTEGER 0 12
RPARENT ) 12
LBRACE { 12
PRINTFSYM printf 13
LPARENT ( 13
STRING "the f2 cannot be 0" 13
RPARENT ) 13
SEMICOLON ; 13
RETURNSYM return 14
LPARENT ( 14
INTEGER 0 14
RPARENT ) 14
SEMICOLON ; 14
RBRACE } 15
ELSESYM else 16
RETURNSYM return 17
LPARENT ( 17
IDENT f1 17
DIVSYM / 17
IDENT f2 17
RPARENT ) 17
SEMICOLON ; 17
RBRACE } 18
VOIDSYM void 20
IDENT print_hello 20
LPARENT ( 20
RPARENT ) 20
LBRACE { 20
IDENT ch 21
BECOME = 21
CHARACTER 'd' 21
SEMICOLON ; 21
PRINTFSYM printf 22
LPARENT ( 22
STRING "hello" 22
RPARENT ) 22
SEMICOLON ; 22
PRINTFSYM printf 23
LPARENT ( 23
STRING "worl" 23
COMMA , 23
IDENT ch 23
RPARENT ) 23
SEMICOLON ; 23
RBRACE } 24
CHARSYM char 26
IDENT get_lower 26
LPARENT ( 26
CHARSYM char 26
IDENT c 26
RPARENT ) 26
LBRACE { 26
IFSYM if 27
LPARENT ( 27
IDENT c 27
GREATER > 27
CHARACTER 'Z' 27
RPARENT ) 27
RETURNSYM return 28
LPARENT ( 28
CHARACTER '_' 28
RPARENT ) 28
SEMICOLON ; 28
ELSESYM else 29
LBRACE { 29
IFSYM if 30
LPARENT ( 30
IDENT c 30
LESS < 30
CHARACTER 'A' 30
RPARENT ) 30
RETURNSYM return 31
LPARENT ( 31
CHARACTER '_' 31
RPARENT ) 31
SEMICOLON ; 31
ELSESYM else 32
RETURNSYM return 33
LPARENT ( 33
IDENT c 33
RPARENT ) 33
SEMICOLON ; 33
RBRACE } 34
RBRACE } 36
INTSYM int 38
IDENT cal_fibonacci_val 38
LPARENT ( 38
INTSYM int 38
IDENT n 38
RPARENT ) 38
LBRACE { 38
IFSYM if 39
LPARENT ( 39
IDENT n 39
LESSEQUAL <= 39
INTEGER 2 39
RPARENT ) 39
RETURNSYM return 40
LPARENT ( 40
INTEGER 1 40
RPARENT ) 40
SEMICOLON ; 40
ELSESYM else 41
RETURNSYM return 42
LPARENT ( 42
IDENT cal_fibonacci_val 42
LPARENT ( 42
IDENT n 42
SUBSYM - 42
INTEGER 1 42
RPARENT ) 42
PLUSSYM + 42
IDENT cal_fibonacci_val 42
LPARENT ( 42
IDENT n 42
SUBSYM - 42
INTEGER 2 42
RPARENT ) 42
RPARENT ) 42
SEMICOLON ; 42
RBRACE } 43
VOIDSYM void 45
MAINSYM main 45
LPARENT ( 45
RPARENT ) 45
LBRACE { 45
CONSTSYM const 47
FLOATSYM float 47
IDENT e 47
BECOME = 47
FLOAT 2.71 47
SEMICOLON ; 47
CHARSYM char 48
IDENT ch1 48
COMMA , 48
IDENT ch2 48
SEMICOLON ; 48
FLOATSYM float 49
IDENT sml_num 49
SEMICOLON ; 49
INTSYM int 50
IDENT x 50
COMMA , 50
IDENT y 50
SEMICOLON ; 50
INTSYM int 51
IDENT i 51
SEMICOLON ; 51
SCANFSYM scanf 52
LPARENT ( 52
IDENT x 52
COMMA , 52
IDENT y 52
RPARENT ) 52
SEMICOLON ; 52
SCANFSYM scanf 53
LPARENT ( 53
IDENT ch1 53
RPARENT ) 53
SEMICOLON ; 53
IFSYM if 55
LPARENT ( 55
IDENT x 55
GREATEREQUAL >= 55
IDENT y 55
RPARENT ) 55
LBRACE { 55
IDENT c 56
LBRACK [ 56
INTEGER 0 56
LBRACK ] 56
BECOME = 56
IDENT x 56
SEMICOLON ; 56
IDENT c 57
LBRACK [ 57
INTEGER 1 57
LBRACK ] 57
BECOME = 57
IDENT y 57
SEMICOLON ; 57
RBRACE } 58
ELSESYM else 59
LBRACE { 59
IDENT c 60
LBRACK [ 60
INTEGER 0 60
LBRACK ] 60
BECOME = 60
IDENT y 60
SEMICOLON ; 60
IDENT c 61
LBRACK [ 61
INTEGER 1 61
LBRACK ] 61
BECOME = 61
IDENT x 61
SEMICOLON ; 61
RBRACE } 62
IDENT i 64
BECOME = 64
IDENT c 64
LBRACK [ 64
INTEGER 0 64
LBRACK ] 64
SUBSYM - 64
IDENT c 64
LBRACK [ 64
INTEGER 1 64
LBRACK ] 64
SEMICOLON ; 64
SEMICOLON ; 66
IDENT _root 68
BECOME = 68
FLOAT 1.23 68
SEMICOLON ; 68
IDENT f1 69
BECOME = 69
PLUSSYM + 69
FLOAT 2.33 69
SEMICOLON ; 69
IDENT res 70
BECOME = 70
INTEGER 2 70
PLUSSYM + 70
INTEGER 5 70
MULSYM * 70
IDENT add_two_nums 70
LPARENT ( 70
IDENT x 70
COMMA , 70
IDENT y 70
RPARENT ) 70
SEMICOLON ; 70
IFSYM if 72
LPARENT ( 72
IDENT res 72
RPARENT ) 72
LBRACE { 72
PRINTFSYM printf 73
LPARENT ( 73
STRING "res is not zero" 73
RPARENT ) 73
SEMICOLON ; 73
PRINTFSYM printf 74
LPARENT ( 74
IDENT res 74
MULSYM * 74
INTEGER 2 74
RPARENT ) 74
SEMICOLON ; 74
RBRACE } 75
IDENT i 77
BECOME = 77
INTEGER 0 77
SEMICOLON ; 77
WHILESYM while 78
LPARENT ( 78
IDENT i 78
NEQUAL != 78
IDENT res 78
RPARENT ) 78
LBRACE { 78
IDENT print_hello 79
LPARENT ( 79
RPARENT ) 79
SEMICOLON ; 79
IDENT i 80
BECOME = 80
IDENT i 80
PLUSSYM + 80
INTEGER 1 80
SEMICOLON ; 80
RBRACE } 81
IDENT i 83
BECOME = 83
INTEGER 2 83
SEMICOLON ; 83
SWITCHSYM switch 84
LPARENT ( 84
IDENT i 84
PLUSSYM + 84
INTEGER 1 84
RPARENT ) 84
LBRACE { 84
CASESYM case 85
INTEGER 2 85
COLON : 85
PRINTFSYM printf 86
LPARENT ( 86
STRING "the value of is 2" 86
RPARENT ) 86
SEMICOLON ; 86
CASESYM case 87
INTEGER 3 87
COLON : 87
PRINTFSYM printf 88
LPARENT ( 88
STRING "the value of i is 3" 88
RPARENT ) 88
SEMICOLON ; 88
RBRACE } 89
IDENT sml_num 91
BECOME = 91
SUBSYM - 91
IDENT float_div 91
LPARENT ( 91
IDENT f1 91
COMMA , 91
IDENT _root 91
RPARENT ) 91
SEMICOLON ; 91
PRINTFSYM printf 92
LPARENT ( 92
IDENT sml_num 92
RPARENT ) 92
SEMICOLON ; 92
IDENT sml_num 93
BECOME = 93
SUBSYM - 93
FLOAT 23.0 93
SEMICOLON ; 93
PRINTFSYM printf 94
LPARENT ( 94
IDENT sml_num 94
RPARENT ) 94
SEMICOLON ; 94
IDENT ch2 96
BECOME = 96
CHARACTER 'A' 96
SEMICOLON ; 96
IDENT ch1 97
BECOME = 97
IDENT get_lower 97
LPARENT ( 97
IDENT ch2 97
RPARENT ) 97
SEMICOLON ; 97
SWITCHSYM switch 98
LPARENT ( 98
IDENT ch1 98
RPARENT ) 98
LBRACE { 98
CASESYM case 99
CHARACTER 'a' 99
COLON : 99
PRINTFSYM printf 100
LPARENT ( 100
STRING "yeyeye" 100
RPARENT ) 100
SEMICOLON ; 100
RBRACE } 101
IDENT ch1 103
BECOME = 103
CHARACTER '2' 103
SEMICOLON ; 103
PRINTFSYM printf 104
LPARENT ( 104
IDENT ch1 104
PLUSSYM + 104
INTEGER 1 104
RPARENT ) 104
SEMICOLON ; 104
IDENT x 107
BECOME = 107
PLUSSYM + 107
INTEGER 6 107
SEMICOLON ; 107
IDENT res 108
BECOME = 108
IDENT cal_fibonacci_val 108
LPARENT ( 108
IDENT x 108
RPARENT ) 108
SEMICOLON ; 108
PRINTFSYM printf 109
LPARENT ( 109
STRING "the fibonacci value is" 109
COMMA , 109
IDENT res 109
RPARENT ) 109
SEMICOLON ; 109
RBRACE } 110
