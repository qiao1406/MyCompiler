CONSTSYM const 1
FLOATSYM float 1
IDENT pi 1
BECOME = 1
FLOAT 3.14 1
SEMICOLON ; 1
CONSTSYM const 2
INTSYM int 2
IDENT buaa 2
BECOME = 2
INTEGER 1952 2
SEMICOLON ; 2
CONSTSYM const 3
FLOATSYM float 3
IDENT fc1 3
BECOME = 3
FLOAT 1 3
COMMA , 3
IDENT fc2 3
BECOME = 3
FLOAT 0.618 3
COMMA , 3
IDENT fc3 3
BECOME = 3
FLOAT -2345. 3
COMMA , 3
IDENT fc4 3
BECOME = 3
FLOAT -245.897 3
SEMICOLON ; 3
CONSTSYM const 4
INTSYM int 4
IDENT a 4
BECOME = 4
INTEGER 5 4
COMMA , 4
IDENT b 4
BECOME = 4
INTEGER 6 4
SEMICOLON ; 4
CONSTSYM const 5
CHARSYM char 5
IDENT aCHAR 5
BECOME = 5
CHARACTER 'a' 5
COMMA , 5
IDENT ___ 5
BECOME = 5
CHARACTER '_' 5
SEMICOLON ; 5
CONSTSYM const 6
CHARSYM char 6
IDENT _66_ 6
BECOME = 6
CHARACTER 'B' 6
SEMICOLON ; 6
INTSYM int 7
IDENT c 7
LBRACK [ 7
INTEGER 2 7
LBRACK ] 7
COMMA , 7
IDENT res 7
COMMA , 7
IDENT d 7
LBRACK [ 7
INTEGER 3 7
LBRACK ] 7
SEMICOLON ; 7
FLOATSYM float 8
IDENT f1 8
COMMA , 8
IDENT _root 8
SEMICOLON ; 8
CHARSYM char 9
IDENT ch 9
SEMICOLON ; 9
INTSYM int 11
IDENT add_two_nums 11
LPARENT ( 11
INTSYM int 11
IDENT a1 11
COMMA , 11
INTSYM int 11
IDENT a2 11
RPARENT ) 11
LBRACE { 11
RETURNSYM return 12
LPARENT ( 12
IDENT a1 12
PLUSSYM + 12
IDENT a2 12
RPARENT ) 12
SEMICOLON ; 12
RBRACE } 13
CHARSYM char 15
IDENT _char_func_ 15
LPARENT ( 15
RPARENT ) 15
LBRACE { 15
RETURNSYM return 16
LPARENT ( 16
CHARACTER 'x' 16
RPARENT ) 16
SEMICOLON ; 16
RBRACE } 17
INTSYM int 19
IDENT cal_fibonacci_val 19
LPARENT ( 19
INTSYM int 19
IDENT n 19
RPARENT ) 19
LBRACE { 19
IFSYM if 20
LPARENT ( 20
IDENT n 20
LESSEQUAL <= 20
INTEGER 2 20
RPARENT ) 20
RETURNSYM return 21
LPARENT ( 21
INTEGER 1 21
RPARENT ) 21
SEMICOLON ; 21
ELSESYM else 22
RETURNSYM return 23
LPARENT ( 23
IDENT cal_fibonacci_val 23
LPARENT ( 23
IDENT n 23
SUBSYM - 23
INTEGER 1 23
RPARENT ) 23
PLUSSYM + 23
IDENT cal_fibonacci_val 23
LPARENT ( 23
IDENT n 23
SUBSYM - 23
INTEGER 2 23
RPARENT ) 23
RPARENT ) 23
SEMICOLON ; 23
RBRACE } 24
FLOATSYM float 27
IDENT float_div 27
LPARENT ( 27
FLOATSYM float 27
IDENT f1 27
COMMA , 27
FLOATSYM float 27
IDENT f2 27
RPARENT ) 27
LBRACE { 27
IFSYM if 28
LPARENT ( 28
IDENT f2 28
EQUAL == 28
INTEGER 0 28
RPARENT ) 28
LBRACE { 28
PRINTFSYM printf 29
LPARENT ( 29
STRING "the f2 cannot be 0" 29
RPARENT ) 29
SEMICOLON ; 29
RETURNSYM return 30
LPARENT ( 30
INTEGER 0 30
RPARENT ) 30
SEMICOLON ; 30
RBRACE } 31
ELSESYM else 32
RETURNSYM return 33
LPARENT ( 33
IDENT f1 33
DIVSYM / 33
IDENT f2 33
RPARENT ) 33
SEMICOLON ; 33
RBRACE } 34
VOIDSYM void 36
IDENT test1 36
LPARENT ( 36
INTSYM int 36
IDENT n 36
RPARENT ) 36
LBRACE { 36
INTSYM int 37
IDENT i 37
SEMICOLON ; 37
IDENT i 38
BECOME = 38
INTEGER 1 38
SEMICOLON ; 38
IFSYM if 39
LPARENT ( 39
IDENT i 39
GREATER > 39
INTEGER 0 39
RPARENT ) 39
LBRACE { 39
WHILESYM while 40
LPARENT ( 40
IDENT i 40
LESS < 40
IDENT n 40
RPARENT ) 40
LBRACE { 40
PRINTFSYM printf 41
LPARENT ( 41
STRING " " 41
COMMA , 41
IDENT cal_fibonacci_val 41
LPARENT ( 41
IDENT i 41
RPARENT ) 41
RPARENT ) 41
SEMICOLON ; 41
IDENT i 42
BECOME = 42
IDENT i 42
PLUSSYM + 42
INTEGER 1 42
SEMICOLON ; 42
RBRACE } 43
RBRACE } 44
ELSESYM else 45
LBRACE { 45
PRINTFSYM printf 46
LPARENT ( 46
STRING "wrong n vlaue" 46
RPARENT ) 46
SEMICOLON ; 46
RBRACE } 47
RBRACE } 48
VOIDSYM void 50
IDENT print_hello 50
LPARENT ( 50
RPARENT ) 50
LBRACE { 50
IDENT ch 51
BECOME = 51
CHARACTER 'd' 51
SEMICOLON ; 51
PRINTFSYM printf 52
LPARENT ( 52
STRING "hello," 52
RPARENT ) 52
SEMICOLON ; 52
PRINTFSYM printf 53
LPARENT ( 53
STRING "worl" 53
COMMA , 53
IDENT ch 53
RPARENT ) 53
SEMICOLON ; 53
PRINTFSYM printf 54
LPARENT ( 54
STRING " " 54
RPARENT ) 54
SEMICOLON ; 54
RBRACE } 55
VOIDSYM void 57
IDENT echo_I 57
LPARENT ( 57
INTSYM int 57
IDENT i 57
RPARENT ) 57
LBRACE { 57
CONSTSYM const 58
CHARSYM char 58
IDENT echo_char 58
BECOME = 58
CHARACTER 'L' 58
SEMICOLON ; 58
PRINTFSYM printf 59
LPARENT ( 59
IDENT echo_char 59
RPARENT ) 59
SEMICOLON ; 59
PRINTFSYM printf 60
LPARENT ( 60
IDENT i 60
RPARENT ) 60
SEMICOLON ; 60
PRINTFSYM printf 61
LPARENT ( 61
STRING " " 61
RPARENT ) 61
SEMICOLON ; 61
RETURNSYM return 62
SEMICOLON ; 62
PRINTFSYM printf 63
LPARENT ( 63
STRING "you can not see it" 63
RPARENT ) 63
SEMICOLON ; 63
RBRACE } 64
CHARSYM char 66
IDENT get_lower 66
LPARENT ( 66
CHARSYM char 66
IDENT c 66
RPARENT ) 66
LBRACE { 66
IFSYM if 67
LPARENT ( 67
IDENT c 67
GREATER > 67
CHARACTER 'Z' 67
RPARENT ) 67
RETURNSYM return 68
LPARENT ( 68
CHARACTER '_' 68
RPARENT ) 68
SEMICOLON ; 68
ELSESYM else 69
LBRACE { 69
IFSYM if 70
LPARENT ( 70
IDENT c 70
LESS < 70
CHARACTER 'A' 70
RPARENT ) 70
RETURNSYM return 71
LPARENT ( 71
CHARACTER '_' 71
RPARENT ) 71
SEMICOLON ; 71
ELSESYM else 72
RETURNSYM return 73
LPARENT ( 73
IDENT c 73
PLUSSYM + 73
INTEGER 32 73
RPARENT ) 73
SEMICOLON ; 73
RBRACE } 74
RBRACE } 76
VOIDSYM void 78
MAINSYM main 78
LPARENT ( 78
RPARENT ) 78
LBRACE { 78
CONSTSYM const 80
FLOATSYM float 80
IDENT e 80
BECOME = 80
FLOAT 2.71 80
SEMICOLON ; 80
CHARSYM char 81
IDENT ch1 81
COMMA , 81
IDENT ch2 81
SEMICOLON ; 81
FLOATSYM float 82
IDENT sml_num 82
SEMICOLON ; 82
INTSYM int 83
IDENT x 83
COMMA , 83
IDENT y 83
SEMICOLON ; 83
INTSYM int 84
IDENT i 84
SEMICOLON ; 84
SCANFSYM scanf 85
LPARENT ( 85
IDENT x 85
COMMA , 85
IDENT y 85
RPARENT ) 85
SEMICOLON ; 85
SCANFSYM scanf 86
LPARENT ( 86
IDENT ch1 86
RPARENT ) 86
SEMICOLON ; 86
IFSYM if 88
LPARENT ( 88
IDENT x 88
GREATEREQUAL >= 88
IDENT y 88
RPARENT ) 88
LBRACE { 88
IDENT c 89
LBRACK [ 89
INTEGER 0 89
LBRACK ] 89
BECOME = 89
IDENT x 89
SEMICOLON ; 89
IDENT c 90
LBRACK [ 90
INTEGER 1 90
LBRACK ] 90
BECOME = 90
IDENT y 90
SEMICOLON ; 90
RBRACE } 91
ELSESYM else 92
LBRACE { 92
IDENT c 93
LBRACK [ 93
INTEGER 0 93
LBRACK ] 93
BECOME = 93
IDENT y 93
SEMICOLON ; 93
IDENT c 94
LBRACK [ 94
INTEGER 1 94
LBRACK ] 94
BECOME = 94
IDENT x 94
SEMICOLON ; 94
RBRACE } 95
IDENT i 97
BECOME = 97
IDENT c 97
LBRACK [ 97
INTEGER 0 97
LBRACK ] 97
SUBSYM - 97
IDENT c 97
LBRACK [ 97
INTEGER 1 97
LBRACK ] 97
SEMICOLON ; 97
SEMICOLON ; 99
IDENT _root 101
BECOME = 101
FLOAT 1.23 101
SEMICOLON ; 101
IDENT f1 102
BECOME = 102
FLOAT +2.33 102
SEMICOLON ; 102
IDENT res 103
BECOME = 103
INTEGER 2 103
MULSYM * 103
IDENT add_two_nums 103
LPARENT ( 103
IDENT x 103
COMMA , 103
IDENT y 103
RPARENT ) 103
SUBSYM - 103
INTEGER 5 103
SEMICOLON ; 103
IFSYM if 105
LPARENT ( 105
IDENT res 105
RPARENT ) 105
LBRACE { 105
PRINTFSYM printf 106
LPARENT ( 106
STRING "res is not zero" 106
COMMA , 106
IDENT res 106
MULSYM * 106
INTEGER 2 106
RPARENT ) 106
SEMICOLON ; 106
PRINTFSYM printf 107
LPARENT ( 107
STRING " " 107
RPARENT ) 107
SEMICOLON ; 107
RBRACE } 108
IDENT i 110
BECOME = 110
INTEGER 10 110
SEMICOLON ; 110
WHILESYM while 111
LPARENT ( 111
IDENT i 111
NEQUAL != 111
IDENT res 111
RPARENT ) 111
LBRACE { 111
IDENT print_hello 112
LPARENT ( 112
RPARENT ) 112
SEMICOLON ; 112
IDENT i 113
BECOME = 113
IDENT i 113
PLUSSYM + 113
INTEGER 1 113
SEMICOLON ; 113
RBRACE } 114
IDENT i 116
BECOME = 116
INTEGER 2 116
SEMICOLON ; 116
SWITCHSYM switch 117
LPARENT ( 117
IDENT i 117
PLUSSYM + 117
INTEGER 1 117
RPARENT ) 117
LBRACE { 117
CASESYM case 118
INTEGER 2 118
COLON : 118
PRINTFSYM printf 119
LPARENT ( 119
STRING "the value of is 2 " 119
RPARENT ) 119
SEMICOLON ; 119
CASESYM case 120
INTEGER 3 120
COLON : 120
PRINTFSYM printf 121
LPARENT ( 121
STRING "the value of i is 3 " 121
RPARENT ) 121
SEMICOLON ; 121
RBRACE } 122
IDENT ch2 127
BECOME = 127
CHARACTER 'A' 127
SEMICOLON ; 127
IDENT ch1 128
BECOME = 128
IDENT get_lower 128
LPARENT ( 128
IDENT ch2 128
RPARENT ) 128
SEMICOLON ; 128
SWITCHSYM switch 129
LPARENT ( 129
IDENT ch1 129
RPARENT ) 129
LBRACE { 129
CASESYM case 130
CHARACTER 'a' 130
COLON : 130
PRINTFSYM printf 131
LPARENT ( 131
STRING " yeyeye" 131
RPARENT ) 131
SEMICOLON ; 131
RBRACE } 132
IDENT ch1 134
BECOME = 134
CHARACTER '2' 134
SEMICOLON ; 134
PRINTFSYM printf 135
LPARENT ( 135
IDENT ch1 135
PLUSSYM + 135
INTEGER 1 135
RPARENT ) 135
SEMICOLON ; 135
IDENT x 138
BECOME = 138
INTEGER +6 138
SEMICOLON ; 138
IDENT res 139
BECOME = 139
IDENT cal_fibonacci_val 139
LPARENT ( 139
IDENT x 139
RPARENT ) 139
SEMICOLON ; 139
PRINTFSYM printf 140
LPARENT ( 140
STRING " the fibonacci value is" 140
COMMA , 140
IDENT res 140
RPARENT ) 140
SEMICOLON ; 140
PRINTFSYM printf 141
LPARENT ( 141
STRING " " 141
RPARENT ) 141
SEMICOLON ; 141
IDENT i 143
BECOME = 143
INTEGER 0 143
SEMICOLON ; 143
WHILESYM while 144
LPARENT ( 144
IDENT i 144
LESS < 144
INTEGER 6 144
RPARENT ) 144
LBRACE { 144
IDENT echo_I 146
LPARENT ( 146
IDENT i 146
PLUSSYM + 146
INTEGER 1 146
RPARENT ) 146
SEMICOLON ; 146
SEMICOLON ; 147
SWITCHSYM switch 148
LPARENT ( 148
IDENT add_two_nums 148
LPARENT ( 148
INTEGER 2 148
MULSYM * 148
IDENT i 148
PLUSSYM + 148
INTEGER 1 148
COMMA , 148
SUBSYM - 148
IDENT i 148
RPARENT ) 148
RPARENT ) 148
LBRACE { 148
CASESYM case 149
INTEGER 1 149
COLON : 149
LBRACE { 149
PRINTFSYM printf 150
LPARENT ( 150
STRING "==== " 150
RPARENT ) 150
SEMICOLON ; 150
PRINTFSYM printf 151
LPARENT ( 151
IDENT add_two_nums 151
LPARENT ( 151
INTEGER -99 151
COMMA , 151
IDENT add_two_nums 151
LPARENT ( 151
INTEGER 20 151
COMMA , 151
INTEGER 0 151
RPARENT ) 151
RPARENT ) 151
RPARENT ) 151
SEMICOLON ; 151
PRINTFSYM printf 152
LPARENT ( 152
STRING " " 152
RPARENT ) 152
SEMICOLON ; 152
RBRACE } 153
CASESYM case 154
INTEGER 2 154
COLON : 154
LBRACE { 154
PRINTFSYM printf 155
LPARENT ( 155
STRING "==== " 155
RPARENT ) 155
SEMICOLON ; 155
IDENT test1 156
LPARENT ( 156
INTEGER 20 156
RPARENT ) 156
SEMICOLON ; 156
PRINTFSYM printf 157
LPARENT ( 157
STRING " " 157
RPARENT ) 157
SEMICOLON ; 157
RBRACE } 158
CASESYM case 159
INTEGER 3 159
COLON : 159
LBRACE { 159
PRINTFSYM printf 160
LPARENT ( 160
STRING "==== " 160
RPARENT ) 160
SEMICOLON ; 160
IDENT res 161
BECOME = 161
SUBSYM - 161
LPARENT ( 161
IDENT add_two_nums 161
LPARENT ( 161
INTEGER 1 161
COMMA , 161
INTEGER 1 161
RPARENT ) 161
PLUSSYM + 161
INTEGER 1 161
RPARENT ) 161
MULSYM * 161
INTEGER 2 161
PLUSSYM + 161
IDENT c 161
LBRACK [ 161
INTEGER 0 161
LBRACK ] 161
MULSYM * 161
IDENT c 161
LBRACK [ 161
INTEGER 1 161
LBRACK ] 161
SEMICOLON ; 161
PRINTFSYM printf 162
LPARENT ( 162
IDENT res 162
RPARENT ) 162
SEMICOLON ; 162
PRINTFSYM printf 163
LPARENT ( 163
STRING " " 163
RPARENT ) 163
SEMICOLON ; 163
IDENT res 164
BECOME = 164
PLUSSYM + 164
LPARENT ( 164
IDENT add_two_nums 164
LPARENT ( 164
INTEGER 1 164
COMMA , 164
INTEGER 2 164
RPARENT ) 164
RPARENT ) 164
MULSYM * 164
INTEGER 2 164
SEMICOLON ; 164
PRINTFSYM printf 165
LPARENT ( 165
IDENT res 165
RPARENT ) 165
SEMICOLON ; 165
PRINTFSYM printf 166
LPARENT ( 166
STRING " " 166
RPARENT ) 166
SEMICOLON ; 166
RBRACE } 167
CASESYM case 168
INTEGER 4 168
COLON : 168
LBRACE { 168
PRINTFSYM printf 169
LPARENT ( 169
STRING "==== " 169
RPARENT ) 169
SEMICOLON ; 169
IDENT sml_num 170
BECOME = 170
SUBSYM - 170
IDENT float_div 170
LPARENT ( 170
IDENT f1 170
COMMA , 170
IDENT _root 170
RPARENT ) 170
SEMICOLON ; 170
PRINTFSYM printf 171
LPARENT ( 171
STRING " " 171
COMMA , 171
IDENT sml_num 171
RPARENT ) 171
SEMICOLON ; 171
IDENT sml_num 172
BECOME = 172
FLOAT -23.7878 172
SEMICOLON ; 172
PRINTFSYM printf 173
LPARENT ( 173
STRING " " 173
COMMA , 173
IDENT sml_num 173
RPARENT ) 173
SEMICOLON ; 173
IDENT sml_num 174
BECOME = 174
IDENT float_div 174
LPARENT ( 174
FLOAT 234.0102 174
COMMA , 174
FLOAT -2.56 174
PLUSSYM + 174
INTEGER 2 174
MULSYM * 174
FLOAT 0.56 174
RPARENT ) 174
SEMICOLON ; 174
PRINTFSYM printf 175
LPARENT ( 175
STRING " " 175
COMMA , 175
IDENT sml_num 175
RPARENT ) 175
SEMICOLON ; 175
PRINTFSYM printf 176
LPARENT ( 176
STRING " " 176
RPARENT ) 176
SEMICOLON ; 176
RBRACE } 177
CASESYM case 178
INTEGER 5 178
COLON : 178
LBRACE { 178
IDENT x 179
BECOME = 179
INTEGER 5 179
SEMICOLON ; 179
PRINTFSYM printf 180
LPARENT ( 180
STRING "==== " 180
RPARENT ) 180
SEMICOLON ; 180
WHILESYM while 181
LPARENT ( 181
IDENT x 181
RPARENT ) 181
LBRACE { 181
PRINTFSYM printf 182
LPARENT ( 182
STRING "@" 182
COMMA , 182
IDENT x 182
RPARENT ) 182
SEMICOLON ; 182
IDENT x 183
BECOME = 183
IDENT x 183
SUBSYM - 183
INTEGER 1 183
SEMICOLON ; 183
RBRACE } 184
PRINTFSYM printf 185
LPARENT ( 185
STRING " " 185
RPARENT ) 185
SEMICOLON ; 185
RBRACE } 186
CASESYM case 187
INTEGER 6 187
COLON : 187
LBRACE { 187
PRINTFSYM printf 188
LPARENT ( 188
STRING "=====Please input a float num" 188
RPARENT ) 188
SEMICOLON ; 188
SCANFSYM scanf 189
LPARENT ( 189
IDENT f1 189
RPARENT ) 189
SEMICOLON ; 189
PRINTFSYM printf 190
LPARENT ( 190
IDENT f1 190
RPARENT ) 190
SEMICOLON ; 190
PRINTFSYM printf 191
LPARENT ( 191
STRING " " 191
RPARENT ) 191
SEMICOLON ; 191
RBRACE } 192
RBRACE } 194
IDENT i 196
BECOME = 196
IDENT i 196
PLUSSYM + 196
INTEGER 1 196
SEMICOLON ; 196
RBRACE } 197
PRINTFSYM printf 199
LPARENT ( 199
STRING "test real constants " 199
COMMA , 199
IDENT fc1 199
RPARENT ) 199
SEMICOLON ; 199
PRINTFSYM printf 200
LPARENT ( 200
STRING "test real constants " 200
COMMA , 200
IDENT fc2 200
RPARENT ) 200
SEMICOLON ; 200
PRINTFSYM printf 201
LPARENT ( 201
STRING "test real constants " 201
COMMA , 201
IDENT fc3 201
RPARENT ) 201
SEMICOLON ; 201
PRINTFSYM printf 202
LPARENT ( 202
STRING "test real constants " 202
COMMA , 202
IDENT fc4 202
RPARENT ) 202
SEMICOLON ; 202
PRINTFSYM printf 203
LPARENT ( 203
STRING "test no argument return_func %%%%%%" 203
COMMA , 203
IDENT _char_func_ 203
LPARENT ( 203
RPARENT ) 203
RPARENT ) 203
SEMICOLON ; 203
RBRACE } 205
