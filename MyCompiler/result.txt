CONSTSYM const 1
FLOATSYM float 1
IDENT pi 1
BECOME = 1
FLOAT 3.14 1
SEMICOLON ; 1
CONSTSYM const 2
FLOATSYM float 2
IDENT fc1 2
BECOME = 2
FLOAT 1 2
COMMA , 2
IDENT fc2 2
BECOME = 2
FLOAT 0.618 2
COMMA , 2
IDENT fc3 2
BECOME = 2
FLOAT -2345. 2
COMMA , 2
IDENT fc4 2
BECOME = 2
FLOAT -245.897 2
SEMICOLON ; 2
CONSTSYM const 3
INTSYM int 3
IDENT a 3
BECOME = 3
INTEGER 5 3
COMMA , 3
IDENT b 3
BECOME = 3
INTEGER 6 3
SEMICOLON ; 3
CONSTSYM const 4
CHARSYM char 4
IDENT aCHAR 4
BECOME = 4
CHARACTER 'a' 4
COMMA , 4
IDENT ___ 4
BECOME = 4
CHARACTER '_' 4
SEMICOLON ; 4
INTSYM int 5
IDENT c 5
LBRACK [ 5
INTEGER 2 5
LBRACK ] 5
COMMA , 5
IDENT res 5
COMMA , 5
IDENT d 5
LBRACK [ 5
INTEGER 3 5
LBRACK ] 5
SEMICOLON ; 5
FLOATSYM float 6
IDENT f1 6
COMMA , 6
IDENT _root 6
SEMICOLON ; 6
CHARSYM char 7
IDENT ch 7
SEMICOLON ; 7
INTSYM int 9
IDENT add_two_nums 9
LPARENT ( 9
INTSYM int 9
IDENT a1 9
COMMA , 9
INTSYM int 9
IDENT a2 9
RPARENT ) 9
LBRACE { 9
RETURNSYM return 10
LPARENT ( 10
IDENT a1 10
PLUSSYM + 10
IDENT a2 10
RPARENT ) 10
SEMICOLON ; 10
RBRACE } 11
CHARSYM char 13
IDENT _char_func_ 13
LPARENT ( 13
RPARENT ) 13
LBRACE { 13
RETURNSYM return 14
LPARENT ( 14
CHARACTER 'x' 14
RPARENT ) 14
SEMICOLON ; 14
RBRACE } 15
FLOATSYM float 17
IDENT float_div 17
LPARENT ( 17
FLOATSYM float 17
IDENT f1 17
COMMA , 17
FLOATSYM float 17
IDENT f2 17
RPARENT ) 17
LBRACE { 17
IFSYM if 18
LPARENT ( 18
IDENT f2 18
EQUAL == 18
INTEGER 0 18
RPARENT ) 18
LBRACE { 18
PRINTFSYM printf 19
LPARENT ( 19
STRING "the f2 cannot be 0" 19
RPARENT ) 19
SEMICOLON ; 19
RETURNSYM return 20
LPARENT ( 20
INTEGER 0 20
RPARENT ) 20
SEMICOLON ; 20
RBRACE } 21
ELSESYM else 22
RETURNSYM return 23
LPARENT ( 23
IDENT f1 23
DIVSYM / 23
IDENT f2 23
RPARENT ) 23
SEMICOLON ; 23
RBRACE } 24
VOIDSYM void 26
IDENT print_hello 26
LPARENT ( 26
RPARENT ) 26
LBRACE { 26
IDENT ch 27
BECOME = 27
CHARACTER 'd' 27
SEMICOLON ; 27
PRINTFSYM printf 28
LPARENT ( 28
STRING "hello" 28
RPARENT ) 28
SEMICOLON ; 28
PRINTFSYM printf 29
LPARENT ( 29
STRING "worl" 29
COMMA , 29
IDENT ch 29
RPARENT ) 29
SEMICOLON ; 29
RETURNSYM return 30
LPARENT ( 30
IDENT ch 30
PLUSSYM + 30
INTEGER 1 30
RPARENT ) 30
SEMICOLON ; 30
RBRACE } 31
CHARSYM char 33
IDENT get_lower 33
LPARENT ( 33
CHARSYM char 33
IDENT c 33
RPARENT ) 33
LBRACE { 33
IFSYM if 34
LPARENT ( 34
IDENT c 34
GREATER > 34
CHARACTER 'Z' 34
RPARENT ) 34
RETURNSYM return 35
LPARENT ( 35
CHARACTER '_' 35
RPARENT ) 35
SEMICOLON ; 35
ELSESYM else 36
LBRACE { 36
IFSYM if 37
LPARENT ( 37
IDENT c 37
LESS < 37
CHARACTER 'A' 37
RPARENT ) 37
RETURNSYM return 38
LPARENT ( 38
CHARACTER '_' 38
RPARENT ) 38
SEMICOLON ; 38
ELSESYM else 39
RETURNSYM return 40
LPARENT ( 40
IDENT c 40
RPARENT ) 40
SEMICOLON ; 40
RBRACE } 41
RBRACE } 43
INTSYM int 45
IDENT cal_fibonacci_val 45
LPARENT ( 45
INTSYM int 45
IDENT n 45
RPARENT ) 45
LBRACE { 45
IFSYM if 46
LPARENT ( 46
IDENT n 46
LESSEQUAL <= 46
INTEGER 2 46
RPARENT ) 46
RETURNSYM return 47
LPARENT ( 47
INTEGER 1 47
RPARENT ) 47
SEMICOLON ; 47
ELSESYM else 48
RETURNSYM return 49
LPARENT ( 49
IDENT cal_fibonacci_val 49
LPARENT ( 49
IDENT n 49
SUBSYM - 49
INTEGER 1 49
RPARENT ) 49
PLUSSYM + 49
IDENT cal_fibonacci_val 49
LPARENT ( 49
IDENT n 49
SUBSYM - 49
INTEGER 2 49
RPARENT ) 49
RPARENT ) 49
SEMICOLON ; 49
RBRACE } 50
VOIDSYM void 52
MAINSYM main 52
LPARENT ( 52
RPARENT ) 52
LBRACE { 52
CONSTSYM const 54
FLOATSYM float 54
IDENT e 54
BECOME = 54
FLOAT 2.71 54
SEMICOLON ; 54
CHARSYM char 55
IDENT ch1 55
COMMA , 55
IDENT ch2 55
SEMICOLON ; 55
FLOATSYM float 56
IDENT sml_num 56
SEMICOLON ; 56
INTSYM int 57
IDENT x 57
COMMA , 57
IDENT y 57
SEMICOLON ; 57
INTSYM int 58
IDENT i 58
SEMICOLON ; 58
SCANFSYM scanf 59
LPARENT ( 59
IDENT x 59
COMMA , 59
IDENT y 59
RPARENT ) 59
SEMICOLON ; 59
SCANFSYM scanf 60
LPARENT ( 60
IDENT ch1 60
RPARENT ) 60
SEMICOLON ; 60
IFSYM if 62
LPARENT ( 62
IDENT x 62
GREATEREQUAL >= 62
IDENT y 62
RPARENT ) 62
LBRACE { 62
IDENT c 63
LBRACK [ 63
INTEGER 0 63
LBRACK ] 63
BECOME = 63
IDENT x 63
SEMICOLON ; 63
IDENT c 64
LBRACK [ 64
INTEGER 1 64
LBRACK ] 64
BECOME = 64
IDENT y 64
SEMICOLON ; 64
RBRACE } 65
ELSESYM else 66
LBRACE { 66
IDENT c 67
LBRACK [ 67
INTEGER 0 67
LBRACK ] 67
BECOME = 67
IDENT y 67
SEMICOLON ; 67
IDENT c 68
LBRACK [ 68
INTEGER 1 68
LBRACK ] 68
BECOME = 68
IDENT x 68
SEMICOLON ; 68
RBRACE } 69
IDENT i 71
BECOME = 71
IDENT c 71
LBRACK [ 71
INTEGER 0 71
LBRACK ] 71
SUBSYM - 71
IDENT c 71
LBRACK [ 71
INTEGER 1 71
LBRACK ] 71
SEMICOLON ; 71
SEMICOLON ; 73
IDENT _root 75
BECOME = 75
FLOAT 1.23 75
SEMICOLON ; 75
IDENT f1 76
BECOME = 76
FLOAT +2.33 76
SEMICOLON ; 76
IDENT res 77
BECOME = 77
INTEGER 2 77
PLUSSYM + 77
INTEGER 5 77
MULSYM * 77
IDENT add_two_nums 77
LPARENT ( 77
IDENT x 77
COMMA , 77
IDENT y 77
RPARENT ) 77
SEMICOLON ; 77
IFSYM if 79
LPARENT ( 79
IDENT res 79
RPARENT ) 79
LBRACE { 79
PRINTFSYM printf 80
LPARENT ( 80
STRING "res is not zero" 80
RPARENT ) 80
SEMICOLON ; 80
PRINTFSYM printf 81
LPARENT ( 81
IDENT res 81
MULSYM * 81
INTEGER 2 81
RPARENT ) 81
SEMICOLON ; 81
RBRACE } 82
IDENT i 84
BECOME = 84
INTEGER 0 84
SEMICOLON ; 84
WHILESYM while 85
LPARENT ( 85
IDENT i 85
NEQUAL != 85
IDENT res 85
RPARENT ) 85
LBRACE { 85
IDENT print_hello 86
LPARENT ( 86
RPARENT ) 86
SEMICOLON ; 86
IDENT i 87
BECOME = 87
IDENT i 87
PLUSSYM + 87
INTEGER 1 87
SEMICOLON ; 87
RBRACE } 88
IDENT i 90
BECOME = 90
INTEGER 2 90
SEMICOLON ; 90
SWITCHSYM switch 91
LPARENT ( 91
IDENT i 91
PLUSSYM + 91
INTEGER 1 91
RPARENT ) 91
LBRACE { 91
CASESYM case 92
INTEGER 2 92
COLON : 92
PRINTFSYM printf 93
LPARENT ( 93
STRING "the value of is 2" 93
RPARENT ) 93
SEMICOLON ; 93
CASESYM case 94
INTEGER 3 94
COLON : 94
PRINTFSYM printf 95
LPARENT ( 95
STRING "the value of i is 3" 95
RPARENT ) 95
SEMICOLON ; 95
RBRACE } 96
IDENT sml_num 98
BECOME = 98
SUBSYM - 98
IDENT float_div 98
LPARENT ( 98
IDENT f1 98
COMMA , 98
IDENT _root 98
RPARENT ) 98
SEMICOLON ; 98
PRINTFSYM printf 99
LPARENT ( 99
IDENT sml_num 99
RPARENT ) 99
SEMICOLON ; 99
IDENT sml_num 100
BECOME = 100
FLOAT -23.0 100
SEMICOLON ; 100
PRINTFSYM printf 101
LPARENT ( 101
IDENT sml_num 101
RPARENT ) 101
SEMICOLON ; 101
IDENT ch2 103
BECOME = 103
CHARACTER 'A' 103
SEMICOLON ; 103
IDENT ch1 104
BECOME = 104
IDENT get_lower 104
LPARENT ( 104
IDENT ch2 104
RPARENT ) 104
SEMICOLON ; 104
SWITCHSYM switch 105
LPARENT ( 105
IDENT ch1 105
RPARENT ) 105
LBRACE { 105
CASESYM case 106
CHARACTER 'a' 106
COLON : 106
PRINTFSYM printf 107
LPARENT ( 107
STRING "yeyeye" 107
RPARENT ) 107
SEMICOLON ; 107
RBRACE } 108
IDENT ch1 110
BECOME = 110
CHARACTER '2' 110
SEMICOLON ; 110
PRINTFSYM printf 111
LPARENT ( 111
IDENT ch1 111
PLUSSYM + 111
INTEGER 1 111
RPARENT ) 111
SEMICOLON ; 111
IDENT x 114
BECOME = 114
INTEGER +6 114
SEMICOLON ; 114
IDENT res 115
BECOME = 115
IDENT cal_fibonacci_val 115
LPARENT ( 115
IDENT x 115
RPARENT ) 115
SEMICOLON ; 115
PRINTFSYM printf 116
LPARENT ( 116
STRING "the fibonacci value is" 116
COMMA , 116
IDENT res 116
RPARENT ) 116
SEMICOLON ; 116
PRINTFSYM printf 119
LPARENT ( 119
STRING "test real constants" 119
COMMA , 119
IDENT fc1 119
RPARENT ) 119
SEMICOLON ; 119
PRINTFSYM printf 120
LPARENT ( 120
STRING "test real constants" 120
COMMA , 120
IDENT fc2 120
RPARENT ) 120
SEMICOLON ; 120
PRINTFSYM printf 121
LPARENT ( 121
STRING "test real constants" 121
COMMA , 121
IDENT fc3 121
RPARENT ) 121
SEMICOLON ; 121
PRINTFSYM printf 122
LPARENT ( 122
STRING "test real constants" 122
COMMA , 122
IDENT fc4 122
RPARENT ) 122
SEMICOLON ; 122
PRINTFSYM printf 123
LPARENT ( 123
STRING "test no argument return_func" 123
COMMA , 123
IDENT _char_func_ 123
LPARENT ( 123
RPARENT ) 123
RPARENT ) 123
SEMICOLON ; 123
RBRACE } 125
