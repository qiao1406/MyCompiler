CONSTSYM const 1
CHARSYM char 1
IDENT tc 1
BECOME = 1
CHARACTER 'a' 1
COMMA , 1
IDENT tc2 1
BECOME = 1
CHARACTER 'A' 1
COMMA , 1
IDENT tc3 1
BECOME = 1
CHARACTER '_' 1
SEMICOLON ; 1
CONSTSYM const 2
FLOATSYM float 2
IDENT pi 2
BECOME = 2
FLOAT 3.14 2
SEMICOLON ; 2
CONSTSYM const 3
INTSYM int 3
IDENT a 3
BECOME = 3
INTEGER 5 3
COMMA , 3
IDENT b 3
BECOME = 3
INTEGER 6 3
SEMICOLON ; 3
INTSYM int 4
IDENT c 4
LBRACK [ 4
INTEGER 2 4
LBRACK ] 4
COMMA , 4
IDENT res 4
COMMA , 4
IDENT d 4
LBRACK [ 4
INTEGER 30 4
LBRACK ] 4
SEMICOLON ; 4
FLOATSYM float 5
IDENT f1 5
COMMA , 5
IDENT _root 5
SEMICOLON ; 5
CHARSYM char 6
IDENT chAABBCC 6
SEMICOLON ; 6
FLOATSYM float 9
IDENT float_div 9
LPARENT ( 9
FLOATSYM float 9
IDENT f1 9
COMMA , 9
FLOATSYM float 9
IDENT f2 9
RPARENT ) 9
LBRACE { 9
IFSYM if 10
LPARENT ( 10
IDENT f2 10
EQUAL == 10
INTEGER 0 10
RPARENT ) 10
LBRACE { 10
PRINTFSYM printf 11
LPARENT ( 11
STRING "the f2 cannot be 0" 11
RPARENT ) 11
SEMICOLON ; 11
RETURNSYM return 12
LPARENT ( 12
INTEGER 0 12
RPARENT ) 12
SEMICOLON ; 12
RBRACE } 13
ELSESYM else 14
RETURNSYM return 15
LPARENT ( 15
IDENT f1 15
DIVSYM / 15
IDENT f2 15
RPARENT ) 15
SEMICOLON ; 15
RBRACE } 16
CHARSYM char 18
IDENT get_lower 18
LPARENT ( 18
CHARSYM char 18
IDENT c 18
RPARENT ) 18
LBRACE { 18
IFSYM if 19
LPARENT ( 19
IDENT c 19
GREATER > 19
CHARACTER 'Z' 19
RPARENT ) 19
RETURNSYM return 20
LPARENT ( 20
CHARACTER '_' 20
RPARENT ) 20
SEMICOLON ; 20
ELSESYM else 21
LBRACE { 21
IFSYM if 22
LPARENT ( 22
IDENT c 22
LESS < 22
CHARACTER 'A' 22
RPARENT ) 22
RETURNSYM return 23
LPARENT ( 23
CHARACTER '_' 23
RPARENT ) 23
SEMICOLON ; 23
ELSESYM else 24
RETURNSYM return 25
LPARENT ( 25
IDENT c 25
RPARENT ) 25
SEMICOLON ; 25
RBRACE } 26
RBRACE } 28
VOIDSYM void 30
MAINSYM main 30
LPARENT ( 30
RPARENT ) 30
LBRACE { 30
CONSTSYM const 32
FLOATSYM float 32
IDENT e 32
BECOME = 32
FLOAT 2.71 32
SEMICOLON ; 32
CHARSYM char 33
IDENT ch1 33
COMMA , 33
IDENT ch2 33
SEMICOLON ; 33
FLOATSYM float 34
IDENT sml_num 34
SEMICOLON ; 34
INTSYM int 35
IDENT x 35
COMMA , 35
IDENT y 35
SEMICOLON ; 35
INTSYM int 36
IDENT i 36
SEMICOLON ; 36
CHARSYM char 37
IDENT kp 37
LBRACK [ 37
INTEGER 23 37
LBRACK ] 37
SEMICOLON ; 37
SCANFSYM scanf 38
LPARENT ( 38
IDENT x 38
COMMA , 38
IDENT y 38
RPARENT ) 38
SEMICOLON ; 38
SCANFSYM scanf 39
LPARENT ( 39
IDENT ch1 39
COMMA , 39
IDENT ch2 39
RPARENT ) 39
SEMICOLON ; 39
SCANFSYM scanf 40
LPARENT ( 40
IDENT sml_num 40
COMMA , 40
IDENT res 40
RPARENT ) 40
SEMICOLON ; 40
IFSYM if 42
LPARENT ( 42
IDENT res 42
RPARENT ) 42
LBRACE { 42
PRINTFSYM printf 43
LPARENT ( 43
STRING "res is not zero" 43
RPARENT ) 43
SEMICOLON ; 43
PRINTFSYM printf 44
LPARENT ( 44
IDENT res 44
MULSYM * 44
INTEGER 2 44
RPARENT ) 44
SEMICOLON ; 44
RBRACE } 45
IDENT chAABBCC 47
BECOME = 47
IDENT get_lower 47
LPARENT ( 47
IDENT ch1 47
RPARENT ) 47
SEMICOLON ; 47
PRINTFSYM printf 48
LPARENT ( 48
STRING "chAABBCC value" 48
RPARENT ) 48
SEMICOLON ; 48
PRINTFSYM printf 49
LPARENT ( 49
IDENT chAABBCC 49
RPARENT ) 49
SEMICOLON ; 49
IFSYM if 51
LPARENT ( 51
IDENT x 51
GREATEREQUAL >= 51
IDENT y 51
RPARENT ) 51
LBRACE { 51
IDENT c 52
LBRACK [ 52
INTEGER 0 52
LBRACK ] 52
BECOME = 52
IDENT x 52
SEMICOLON ; 52
IDENT c 53
LBRACK [ 53
INTEGER 1 53
LBRACK ] 53
BECOME = 53
IDENT y 53
SEMICOLON ; 53
RBRACE } 54
ELSESYM else 55
LBRACE { 55
IDENT c 56
LBRACK [ 56
INTEGER 0 56
LBRACK ] 56
BECOME = 56
IDENT y 56
SEMICOLON ; 56
IDENT c 57
LBRACK [ 57
INTEGER 1 57
LBRACK ] 57
BECOME = 57
IDENT x 57
SEMICOLON ; 57
RBRACE } 58
PRINTFSYM printf 60
LPARENT ( 60
IDENT c 60
LBRACK [ 60
INTEGER 0 60
LBRACK ] 60
RPARENT ) 60
SEMICOLON ; 60
PRINTFSYM printf 61
LPARENT ( 61
STRING "qijihaha" 61
COMMA , 61
IDENT float_div 61
LPARENT ( 61
IDENT pi 61
COMMA , 61
IDENT sml_num 61
RPARENT ) 61
RPARENT ) 61
SEMICOLON ; 61
RBRACE } 63
